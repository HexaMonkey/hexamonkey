//This file is part of the HexaMonkey project, a multimedia analyser
//Copyright (C) 2013  Sevan Drapeau-Martin, Nicolas Fleury

//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

addMagicNumber 4d 5a
addExtension exe

import microsoft

class PEFile as File
{
	IMAGE_DOS_HEADER _dos_header;
	IMAGE_DOS_SEGMENT(_dos_header.e_lfanew-(@pos>>3)) _dos_segment;
	IMAGE_NT_HEADERS _nt_header;
	IMAGE_SECTION_HEADER _section_headers[_nt_header.FileHeader.NumberOfSections];
	IMAGE_SECTIONS _image_sections;
}

class IMAGE_DOS_HEADER {      // DOS .EXE header
	WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
}

class IMAGE_DOS_SEGMENT(_size) extends Data(_size<<3) 

class IMAGE_NT_HEADERS 
{
  DWORD                 Signature;
  IMAGE_FILE_HEADER     FileHeader;
  if (FileHeader.SizeOfOptionalHeader) {
	IMAGE_OPTIONAL_HEADER OptionalHeader;
  }
}

class ADDRESS extends DWORD(16)
{
	if (@value) {
		@linkTo = 8*@value;
	}
}

class RVA(_offset) extends DWORD(16)
{
	if (@value) {
		var offset = @args._offset;
		@linkTo = 8*@value + (offset?offset:0);
	}
}

class OFFSET extends DWORD(16)

class IMAGE_FILE_HEADER {
  IMAGE_FILE_MACHINE  Machine;
  WORD                NumberOfSections;
  DWORD               TimeDateStamp;      
  ADDRESS               PointerToSymbolTable;
  DWORD               NumberOfSymbols;
  WORD                SizeOfOptionalHeader;
  WORD                Characteristics;
}

class IMAGE_FILE_MACHINE extends WORD
{
	if (@value == 0x014c) {
		@attr[] = '"x86"';
	} else if (@value == 0x0200) {
		@attr[] = '"Intel Itanium"';
	} else if (@value == 0x8664) {
		@attr[] = '"x64"';
	}
}

class IMAGE_OPTIONAL_HEADER 
{
	WORD   Magic;
	var HDR64 = @root.@attr._HDR64 = (Magic == 0x20b);
	%log(""+@root._HDR64);
	BYTE   MajorLinkerVersion;
	BYTE   MinorLinkerVersion;
	OFFSET  SizeOfCode;
	OFFSET  SizeOfInitializedData;
	OFFSET  SizeOfUninitializedData;
	OFFSET  AddressOfEntryPoint;
	OFFSET  BaseOfCode;
	if (HDR64) {
		ULONGLONG  ImageBase;
	} else {
		DWORD  BaseOfData;
		DWORD  ImageBase;
	}
	DWORD  SectionAlignment;
	DWORD  FileAlignment;
	WORD   MajorOperatingSystemVersion;
	WORD   MinorOperatingSystemVersion;
	WORD   MajorImageVersion;
	WORD   MinorImageVersion;
	WORD   MajorSubsystemVersion;
	WORD   MinorSubsystemVersion;
	DWORD  Win32VersionValue;
	DWORD  SizeOfImage;
	DWORD  SizeOfHeaders;
	DWORD  CheckSum;
	WORD   Subsystem;
	WORD   DllCharacteristics;
	
	var SIZE_TYPE = (HDR64 ? ULONGLONG(16) : DWORD(16));
	(SIZE_TYPE)  SizeOfStackReserve;
	(SIZE_TYPE)  SizeOfStackCommit;
	(SIZE_TYPE)  SizeOfHeapReserve;
	(SIZE_TYPE)  SizeOfHeapCommit;
	
	DWORD  LoaderFlags;
	DWORD  NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[NumberOfRvaAndSizes];
}

class IMAGE_DATA_DIRECTORY
{
	DWORD VirtualAddress;
	DWORD Size;
}

class IMAGE_SECTION_HEADER
{
    String(8) Name;
	@value = Name;
    DWORD(16) VirtualSize;
    DWORD(16) VirtualAddress;
    DWORD(16) SizeOfRawData;
    RVA PointerToRawData;
	@linkTo = PointerToRawData.@linkTo;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
}

class IMAGE_SECTION(name, _size, _virtualOffset)
{
	@attr._offset = @beginningPos - 8*@args._virtualOffset;
	//%log("1:"+_virtualOffset+":"+@args._virtualOffset+":"+@args._size+@args.name);
	@size = @args._size<<3;
}

class IMAGE_SECTIONS
{
	@args.@elementType = IMAGE_SECTION();
	var n = @args.@elementCount = @parent._nt_header.FileHeader.NumberOfSections;
	for (var i = 0; i < n; ++i) {
		var sectionOffset = @parent._section_headers[i].PointerToRawData;
		var sectionSize   = @parent._section_headers[i].SizeOfRawData;
		var sectionName   = @parent._section_headers[i].Name;
		var sectionVirtualOffset   = @parent._section_headers[i].VirtualAddress;

		@pos = (sectionOffset << 3) - @beginningPos;
		IMAGE_SECTION(sectionName, sectionSize, sectionVirtualOffset) *;
	}
}

//*********************************************************
// IAT
//*********************************************************
class IMAGE_SECTION_IAT() as IMAGE_SECTION(".idata")
{
	IMAGE_IMPORT_DESCRIPTORS(_offset) _descriptors;
	var originalPos = _descriptors.@size;
	IMAGE_IMPORT_NAMES(_offset) _names;
	@pos = originalPos;
	IMAGE_IMPORT_DATAS(_offset) _data;
}


class IMAGE_IMPORT_NAME extends String

class IMAGE_IMPORT_NAMES extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_NAME();
	var n = @args.@elementCount = @parent._descriptors.@numberOfChildren - 1;
	for  (var i = 0; i < n; ++i) {
		@pos = @parent._descriptors[i].Name.@linkTo - @beginningPos;
		IMAGE_IMPORT_NAME #;
	}
}

class IMAGE_IMPORT_DATAS(_offset) extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_DATA();
	var n = @args.@elementCount = @parent._descriptors.@numberOfChildren - 1;
	for (var i = 0; i < n; ++i) {
		IMAGE_IMPORT_DATA(@parent._descriptors[i].OriginalFirstThunk.@linkTo, @args._offset) #;
		@pos = 0;
	}
}

class IMAGE_IMPORT_DATA(_originalFirstThunk, _offset) extends Data(-1)
{
	@pos = @args._originalFirstThunk - @beginningPos;
	IMAGE_THUNK_DATAS(@args._offset) _data;
	var n = _data.@numberOfChildren - 1;
	var importCount = 0;
	for (var i = 0; i < n; ++i) {
		if (_data[i].@linkTo) {
			++importCount;
		}
	}
	if (importCount > 0) {
		IMAGE_IMPORT_BY_NAMES(importCount) _;
	}
}

class IMAGE_THUNK_DATA32(_offset) extends DWORD(16)
{
	if (@value & 0x80000000) {
		@attr.Ordinal = @value & 0x7fffffff;
	} else if (@value) {
		var offset = @args._offset;
		@linkTo = 8*@value + (offset?offset:0);
		@attr.AddressOfData = @value;
	}
}

class IMAGE_THUNK_DATA64(_offset) extends ULONGLONG(16)
{
	if (@value & 0x8000000000000000) {
		@attr.Ordinal = @value & 0x7fffffffffffffff;
	} else if (@value) {
		var offset = @args._offset;
		@linkTo = 8*@value + (offset?offset:0);
		@attr.AddressOfData = @value;
	}
	@value = NULL;
}

class IMAGE_THUNK_DATAS(_offset)
{
	if (@root._HDR64) {
		var elementType = IMAGE_THUNK_DATA64(@args._offset);
	} else {
		var elementType = IMAGE_THUNK_DATA32(@args._offset);
	}
	@args.@elementType = elementType;
	var n = 0;
	do {
		(elementType) #;
		++n;
	} while ([] != 0)
	@args.@elementCount = n;
}

class IMAGE_IMPORT_DESCRIPTORS(_offset)
{
	@args.@elementType = IMAGE_IMPORT_DESCRIPTOR();
	var n = 0;
	do {
		IMAGE_IMPORT_DESCRIPTOR(@args._offset) #;
		++n;
	} while ([].OriginalFirstThunk != 0)
	@args.@elementCount = n;
}

class IMAGE_IMPORT_DESCRIPTOR(_offset)
{
    RVA(@args._offset)  OriginalFirstThunk; // It points to the first thunk IMAGE_THUNK_DATA
	DWORD      TimeDateStamp;               // 0 if not bound
	DWORD      ForwarderChain;              // -1 if no forwarders
	RVA(@args._offset)  Name;               // RVA of DLL Name.
	RVA(@args._offset)  FirstThunk;         // RVA to IAT (if bound this IAT has actual addresses)
}

class IMAGE_IMPORT_BY_NAME
{
	WORD Hint;
	String Name;
    @attr.Hint = Hint;
    @attr.Name = Name;
}

class IMAGE_IMPORT_BY_NAMES(_count) extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_BY_NAME();
	@args.@elementCount = @args._count;
	var n = @parent._data.@numberOfChildren - 1;
	for (var i = 0; i < n; ++i) {
		var linkTo = @parent._data[i].@linkTo;
		if (linkTo) {
			@pos = @parent._data[i].@linkTo - @beginningPos;
			IMAGE_IMPORT_BY_NAME #;
		}
	}
}

//*********************************************************
// Relocation table
//*********************************************************
class IMAGE_SECTION_RELOCATION() as IMAGE_SECTION(".reloc")
{
	do {
		IMAGE_BASE_RELOCATION #;
    } while ([].VirtualAddress)
}

class IMAGE_BASE_RELOCATION
{
	DWORD VirtualAddress;
	DWORD SizeOfBlock;
	if (SizeOfBlock) {
		WORD _items [(8*SizeOfBlock-@pos)/%sizeof(WORD())];
	}
}
