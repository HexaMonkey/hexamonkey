//This file is part of the HexaMonkey project, a multimedia analyser
//Copyright (C) 2013  Sevan Drapeau-Martin, Nicolas Fleury

//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

addMagicNumber 4d 5a
addExtension exe

import microsoft

class PEFile as File
{
	IMAGE_DOS_HEADER _dos_header;
	IMAGE_DOS_SEGMENT(_dos_header.e_lfanew-(@pos>>3)) _dos_segment;
	IMAGE_NT_HEADERS _nt_header;
	IMAGE_SECTION_HEADER _section_headers[_nt_header.FileHeader.NumberOfSections];
	IMAGE_SECTIONS _image_sections;
}

class IMAGE_DOS_HEADER {      // DOS .EXE header
	WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
}

class IMAGE_DOS_SEGMENT(_size) extends Data(_size<<3) 

class IMAGE_NT_HEADERS 
{
  DWORD                 Signature;
  IMAGE_FILE_HEADER     FileHeader;
  if (FileHeader.SizeOfOptionalHeader) {
	IMAGE_OPTIONAL_HEADER OptionalHeader;
  }
}

class ADDRESS extends DWORD(16)
{
	if (@value) {
		@linkTo = 8*@value;
	}
}

class RVA extends DWORD(16)
{
	if (@value) {
		var offset = @context.currentOffset;
		@linkTo = 8*@value + (offset?offset:0);
	}
}

class OFFSET extends DWORD(16)

class IMAGE_FILE_HEADER {
  IMAGE_FILE_MACHINE  Machine;
  WORD                NumberOfSections;
  DWORD               TimeDateStamp;      
  ADDRESS             PointerToSymbolTable;
  DWORD               NumberOfSymbols;
  WORD                SizeOfOptionalHeader;
  WORD                Characteristics;
}

class IMAGE_FILE_MACHINE extends WORD
{
	if (@value == 0x014c) {
		@attr[] = '"x86"';
	} else if (@value == 0x0200) {
		@attr[] = '"Intel Itanium"';
	} else if (@value == 0x8664) {
		@attr[] = '"x64"';
	}
}

class IMAGE_OPTIONAL_HEADER 
{
	WORD   Magic;
	var HDR64 = @global.HDR64 = (Magic == 0x20b);
	BYTE   MajorLinkerVersion;
	BYTE   MinorLinkerVersion;
	OFFSET  SizeOfCode;
	OFFSET  SizeOfInitializedData;
	OFFSET  SizeOfUninitializedData;
	OFFSET  AddressOfEntryPoint;
	OFFSET  BaseOfCode;
	if (HDR64) {
		ULONGLONG  ImageBase;
	} else {
		DWORD  BaseOfData;
		DWORD  ImageBase;
	}
	DWORD  SectionAlignment;
	DWORD  FileAlignment;
	WORD   MajorOperatingSystemVersion;
	WORD   MinorOperatingSystemVersion;
	WORD   MajorImageVersion;
	WORD   MinorImageVersion;
	WORD   MajorSubsystemVersion;
	WORD   MinorSubsystemVersion;
	DWORD  Win32VersionValue;
	DWORD  SizeOfImage;
	DWORD  SizeOfHeaders;
	DWORD  CheckSum;
	WORD   Subsystem;
	WORD   DllCharacteristics;
	
	var SIZE_TYPE = (HDR64 ? ULONGLONG(16) : DWORD(16));
	(SIZE_TYPE)  SizeOfStackReserve;
	(SIZE_TYPE)  SizeOfStackCommit;
	(SIZE_TYPE)  SizeOfHeapReserve;
	(SIZE_TYPE)  SizeOfHeapCommit;
	
	DWORD  LoaderFlags;
	DWORD  NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[NumberOfRvaAndSizes];
}

class IMAGE_DATA_DIRECTORY
{
	DWORD(16) VirtualAddress;
	DWORD(16) Size;
}

class IMAGE_SECTION_HEADER
{
    String(8) Name;
	@value = Name;
    DWORD(16) VirtualSize;
    DWORD(16) VirtualAddress;
    DWORD(16) SizeOfRawData;
    RVA PointerToRawData;
	@linkTo = PointerToRawData.@linkTo;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
}

class IMAGE_SECTION(name, _size, _virtualOffset) as Data(_size << 3)
{
	var minVirtualOffset = @args._virtualOffset;
	var maxVirtualOffset = @args._virtualOffset + @args._size;
	var currentOffset = @context.currentOffset = @beginningPos - 8*minVirtualOffset;
	---
	var count = @root._nt_header.OptionalHeader.NumberOfRvaAndSizes;
	%log("count : "+count);
	for (var i = 0; i < count; ++i) {
		var directoryVirtualOffset = @root._nt_header.OptionalHeader.DataDirectory[i].VirtualAddress;
		%log("Offset check "+i+" "+ minVirtualOffset + "<=" + directoryVirtualOffset + "<" + maxVirtualOffset);
		if (minVirtualOffset <= directoryVirtualOffset && directoryVirtualOffset < maxVirtualOffset) {
			@pos = 8*(directoryVirtualOffset - minVirtualOffset);
			%log(""+@pos+" -> "+(@root._nt_header.OptionalHeader.DataDirectory[i].Size << 3));
			IMAGE_DIRECTORY_ENTRY(i, @root._nt_header.OptionalHeader.DataDirectory[i].Size << 3) _;
			@pos = 0;
		}
	}
}

class IMAGE_SECTIONS
{
	@args.@elementType = IMAGE_SECTION();
	var n = @args.@elementCount = @parent._nt_header.FileHeader.NumberOfSections;
	for (var i = 0; i < n; ++i) {
		var sectionOffset = @parent._section_headers[i].PointerToRawData;
		var sectionSize   = @parent._section_headers[i].SizeOfRawData;
		var sectionName   = @parent._section_headers[i].Name;
		var sectionVirtualOffset   = @parent._section_headers[i].VirtualAddress;

		@pos = (sectionOffset << 3) - @beginningPos;
		IMAGE_SECTION(sectionName, sectionSize, sectionVirtualOffset) *;
	}
}

class IMAGE_DIRECTORY_ENTRY(index, _size) extends Data(-1)

//*********************************************************
// Export table
//*********************************************************
class IMAGE_DIRECTORY_ENTRY_EXPORT as IMAGE_DIRECTORY_ENTRY(0)
{
	IMAGE_EXPORT_DIRECTORY _directory;
	
	@pos = _directory.AddressOfFunctions.@linkTo - @beginningPos;
	DWORD FunctionsAddresses[_directory.NumberOfFunctions];
	
	var numberOfNames = _directory.NumberOfNames;
	
	@pos = _directory.AddressOfNames.@linkTo - @beginningPos;
	RVA NamesAddresses[numberOfNames];
	
	@pos = _directory.AddressOfNameOrdinals.@linkTo - @beginningPos;
	WORD NamesOrdinals[numberOfNames];
	
	@pos = _directory.Name.@linkTo - @beginningPos;
	String Name;
	
	if (numberOfNames > 0) {
		var minLink = NamesAddresses[0].@linkTo;
		for (var i = 1; i < numberOfNames; ++i) {
			var link = NamesAddresses[i].@linkTo;
			%log(link);
			if (link < minLink) {
				link = minLink;
			}
		}
		
		@pos = minLink - @beginningPos;
		
		IMAGE_EXPORT_NAMES(numberOfNames) _names;
	}
}

class IMAGE_EXPORT_DIRECTORY
{
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    RVA     Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    RVA     AddressOfFunctions;
    RVA     AddressOfNames;
    RVA     AddressOfNameOrdinals;
}

class IMAGE_EXPORT_NAMES(_count) extends Data(-1)
{
	@args.@elementType = String();
	var count = @args.@elementCount = @args._count;
	for (var i = 0; i < count; ++i) {
		@pos = @parent.NamesAddresses[i].@linkTo - @beginningPos;
		String #;
		@pos = 0;
	}
}

//*********************************************************
// Import table
//*********************************************************
class IMAGE_DIRECTORY_ENTRY_IMPORT as IMAGE_DIRECTORY_ENTRY(1)
{
	IMAGE_IMPORT_DESCRIPTORS _descriptors;
	var originalPos = _descriptors.@size;
	IMAGE_IMPORT_NAMES _names;
	@pos = originalPos;
	IMAGE_IMPORT_DATAS _data;
}


class IMAGE_IMPORT_NAME extends String

class IMAGE_IMPORT_NAMES extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_NAME();
	var n = @args.@elementCount = @parent._descriptors.@numberOfChildren - 1;
	for  (var i = 0; i < n; ++i) {
		@pos = @parent._descriptors[i].Name.@linkTo - @beginningPos;
		IMAGE_IMPORT_NAME #;
	}
}

class IMAGE_IMPORT_DATAS extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_DATA();
	var n = @args.@elementCount = @parent._descriptors.@numberOfChildren - 1;
	for (var i = 0; i < n; ++i) {
		IMAGE_IMPORT_DATA(@parent._descriptors[i].OriginalFirstThunk.@linkTo) #;
		@pos = 0;
	}
}

class IMAGE_IMPORT_DATA(_originalFirstThunk) extends Data(-1)
{
	@pos = @args._originalFirstThunk - @beginningPos;
	IMAGE_THUNK_DATAS _data;
	var n = _data.@numberOfChildren - 1;
	var importCount = 0;
	for (var i = 0; i < n; ++i) {
		if (_data[i].@linkTo) {
			++importCount;
		}
	}
	if (importCount > 0) {
		IMAGE_IMPORT_BY_NAMES(importCount) _;
	}
}

class IMAGE_THUNK_DATA32 extends DWORD(16)
{
	if (@value & 0x80000000) {
		@attr.Ordinal = @value & 0x7fffffff;
	} else if (@value) {
		var offset = @context.currentOffset;
		@linkTo = 8*@value + (offset?offset:0);
		@attr.AddressOfData = @value;
	}
}

class IMAGE_THUNK_DATA64 extends ULONGLONG(16)
{
	if (@value & 0x8000000000000000) {
		@attr.Ordinal = @value & 0x7fffffffffffffff;
	} else if (@value) {
		var offset = @context.currentOffset;
		@linkTo = 8*@value + (offset?offset:0);
		@attr.AddressOfData = @value;
	}
	@value = NULL;
}

class IMAGE_THUNK_DATAS
{
	if (@global.HDR64) {
		var elementType = IMAGE_THUNK_DATA64();
	} else {
		var elementType = IMAGE_THUNK_DATA32();
	}
	@args.@elementType = elementType;
	
	var n = 0;
	do {
		(elementType) #;
		++n;
	} while ([] != 0)
	@args.@elementCount = n;
}

class IMAGE_IMPORT_DESCRIPTORS
{
	@args.@elementType = IMAGE_IMPORT_DESCRIPTOR();
	var n = 0;
	do {
		IMAGE_IMPORT_DESCRIPTOR #;
		++n;
	} while ([].OriginalFirstThunk != 0)
	@args.@elementCount = n;
}

class IMAGE_IMPORT_DESCRIPTOR
{
    RVA   OriginalFirstThunk; // It points to the first thunk IMAGE_THUNK_DATA
	DWORD TimeDateStamp;      // 0 if not bound
	DWORD ForwarderChain;     // -1 if no forwarders
	RVA   Name;               // RVA of DLL Name.
	RVA   FirstThunk;         // RVA to IAT (if bound this IAT has actual addresses)
}

class IMAGE_IMPORT_BY_NAME
{
	WORD Hint;
	String Name;
    @attr.Hint = Hint;
    @attr.Name = Name;
}

class IMAGE_IMPORT_BY_NAMES(_count) extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_BY_NAME();
	@args.@elementCount = @args._count;
	var n = @parent._data.@numberOfChildren - 1;
	for (var i = 0; i < n; ++i) {
		var linkTo = @parent._data[i].@linkTo;
		if (linkTo) {
			@pos = linkTo - @beginningPos;
			IMAGE_IMPORT_BY_NAME #;
		}
	}
}

//*********************************************************
// Resource
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_RESOURCE as IMAGE_DIRECTORY_ENTRY(2)

//*********************************************************
// Exception
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_EXCEPTION as IMAGE_DIRECTORY_ENTRY(3)

//*********************************************************
// Security
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_SECURITY as IMAGE_DIRECTORY_ENTRY(4)

//*********************************************************
// Relocation table
//*********************************************************
class IMAGE_DIRECTORY_ENTRY_BASERELOC as IMAGE_DIRECTORY_ENTRY(5)
{
	do {
		IMAGE_BASE_RELOCATION #;
    } while ([].VirtualAddress)
}

class IMAGE_BASE_RELOCATION
{
	DWORD VirtualAddress;
	DWORD SizeOfBlock;
	if (SizeOfBlock) {
		IMAGE_BASE_RELOCATION_ITEM _items [(8*SizeOfBlock-@pos)/%sizeof(WORD())];
	}
}

class IMAGE_BASE_RELOCATION_ITEM extends WORD
{
	@attr.Type = @value >> 12;
	@value &= 0x0fff;
}

//*********************************************************
// Debug
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_DEBUG as IMAGE_DIRECTORY_ENTRY(6)

//*********************************************************
// Copyright
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_COPYRIGHT as IMAGE_DIRECTORY_ENTRY(7)

//*********************************************************
// Global ptr
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_EXCEPTION as IMAGE_DIRECTORY_ENTRY(8)

//********************************************************
// Thread local storage
//********************************************************

class IMAGE_DIRECTORY_ENTRY_TLS as IMAGE_DIRECTORY_ENTRY(9)

//********************************************************
// Load configuration
//********************************************************

class IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG as IMAGE_DIRECTORY_ENTRY(10)

//********************************************************
// Bound import
//********************************************************

class IMAGE_DIRECTORY_BOUND_IMPORT as IMAGE_DIRECTORY_ENTRY(11)

//********************************************************
// Import address table
//********************************************************

class IMAGE_DIRECTORY_ENTRY_IAT as IMAGE_DIRECTORY_ENTRY(12)

//********************************************************
// Delay import descriptor
//********************************************************

class IMAGE_DIRECTORY_ENTRY_DELAY as IMAGE_DIRECTORY_ENTRY(13)

//********************************************************
// COM+ Runtime Header
//********************************************************

class IMAGE_DIRECTORY_ENTRY_COM as IMAGE_DIRECTORY_ENTRY(14)







