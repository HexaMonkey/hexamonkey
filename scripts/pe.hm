//This file is part of the HexaMonkey project, a multimedia analyser
//Copyright (C) 2013  Sevan Drapeau-Martin, Nicolas Fleury

//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

addMagicNumber 4d 5a
addExtension exe

import microsoft

class PEFile as File
{
	IMAGE_DOS_HEADER _dos_header;
	IMAGE_DOS_SEGMENT(_dos_header.e_lfanew-(@pos>>3)) _dos_segment;
	IMAGE_NT_HEADERS _nt_header;
	IMAGE_SECTION_HEADER _section_headers[_nt_header.FileHeader.NumberOfSections];
	IMAGE_SECTIONS _image_sections;
}

class IMAGE_DOS_HEADER {      // DOS .EXE header
	WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
}

class IMAGE_DOS_SEGMENT(_size) extends Data(_size<<3) 

class IMAGE_NT_HEADERS 
{
  DWORD                 Signature;
  IMAGE_FILE_HEADER     FileHeader;
  if (FileHeader.SizeOfOptionalHeader) {
	IMAGE_OPTIONAL_HEADER OptionalHeader;
  }
} 

class IMAGE_FILE_HEADER {
  IMAGE_FILE_MACHINE  Machine;
  WORD                NumberOfSections;
  DWORD               TimeDateStamp;      
  DWORD               PointerToSymbolTable;
  DWORD               NumberOfSymbols;
  WORD                SizeOfOptionalHeader;
  WORD                Characteristics;
}

class IMAGE_FILE_MACHINE extends WORD
{
	if (@value == 0x014c) {
		@info = '"x86"';
	} else if (@value == 0x0200) {
		@info = '"Intel Itanium"';
	} else if (@value == 0x8664) {
		@info = '"x64"';
	}
}

class IMAGE_OPTIONAL_HEADER 
{
	WORD   Magic;
	var HDR64 = (Magic == 0x20b);
	BYTE   MajorLinkerVersion;
	BYTE   MinorLinkerVersion;
	DWORD  SizeOfCode;
	DWORD  SizeOfInitializedData;
	DWORD  SizeOfUninitializedData;
	DWORD  AddressOfEntryPoint;
	DWORD  BaseOfCode;
	if (HDR64) {
		ULONGLONG  ImageBase;
	} else {
		DWORD  BaseOfData;
		DWORD  ImageBase;
	}
	DWORD  SectionAlignment;
	DWORD  FileAlignment;
	WORD   MajorOperatingSystemVersion;
	WORD   MinorOperatingSystemVersion;
	WORD   MajorImageVersion;
	WORD   MinorImageVersion;
	WORD   MajorSubsystemVersion;
	WORD   MinorSubsystemVersion;
	DWORD  Win32VersionValue;
	DWORD  SizeOfImage;
	DWORD  SizeOfHeaders;
	DWORD  CheckSum;
	WORD   Subsystem;
	WORD   DllCharacteristics;
	
	var SIZE_TYPE = (HDR64 ? ULONGLONG() : DWORD());
	(SIZE_TYPE)  SizeOfStackReserve;
	(SIZE_TYPE)  SizeOfStackCommit;
	(SIZE_TYPE)  SizeOfHeapReserve;
	(SIZE_TYPE)  SizeOfHeapCommit;
	
	DWORD  LoaderFlags;
	DWORD  NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[NumberOfRvaAndSizes];
}

class IMAGE_DATA_DIRECTORY
{
	DWORD VirtualAddress;
	DWORD Size;
}

class IMAGE_SECTION_HEADER
{
    String(8) Name;
	@value = Name;
    DWORD(16) VirtualSize;
    DWORD(16) VirtualAddress;
    DWORD(16) SizeOfRawData;
    DWORD(16) PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
}

class IMAGE_SECTION(name, _size) extends Data(_size<<3)

class IMAGE_SECTIONS
{
	@args.@elementType = IMAGE_SECTION();
	var n = @args.@elementCount = @parent._nt_header.FileHeader.NumberOfSections;
	for (var i = 0; i < n; ++i) {
		var sectionOffset = @parent._section_headers[i].PointerToRawData;
		var sectionSize   = @parent._section_headers[i].SizeOfRawData;
		var sectionName   = @parent._section_headers[i].Name;

		@pos = (sectionOffset << 3) - @beginningPos;
		IMAGE_SECTION(sectionName, sectionSize) *;
	}
}

class IMAGE_SECTION_IAT as IMAGE_SECTION(".idata")
{
	IMAGE_IMPORT_DESCRIPTORS _descriptors;
}

class IMAGE_IMPORT_DESCRIPTORS
{
	@args.@elementType = IMAGE_IMPORT_DESCRIPTOR();
	var n = 0;
	do {
		IMAGE_IMPORT_DESCRIPTOR #;
		++n;
	} while ([].OriginalFirstThunk != 0)
	@args.@elementCount = n;
}

class IMAGE_IMPORT_DESCRIPTOR
{
    DWORD   OriginalFirstThunk; // It points to the first thunk IMAGE_THUNK_DATA
	DWORD   TimeDateStamp;      // 0 if not bound
    DWORD   ForwarderChain;     // -1 if no forwarders
    DWORD   Name;               // RVA of DLL Name.
    DWORD   FirstThunk;         // RVA to IAT (if bound this IAT has actual addresses)
}
