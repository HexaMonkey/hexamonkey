//This file is part of the HexaMonkey project, a multimedia analyser
//Copyright (C) 2013  Sevan Drapeau-Martin, Nicolas Fleury

//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

addMagicNumber 4d 5a
addExtension exe

import microsoft

class PEFile as File
{
	IMAGE_DOS_HEADER _dos_header;
	IMAGE_DOS_SEGMENT((_dos_header.e_lfanew<<3)-@pos) _dos_segment;
	IMAGE_NT_HEADERS _nt_header;
	IMAGE_SECTION_HEADER _section_headers[_nt_header.FileHeader.NumberOfSections];
	IMAGE_SECTIONS _image_sections;
}

class IMAGE_DOS_HEADER {      // DOS .EXE header
	WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
}

class IMAGE_DOS_SEGMENT(_size) extends Data(_size) 

class IMAGE_NT_HEADERS 
{
  DWORD                 Signature;
  IMAGE_FILE_HEADER     FileHeader;
  if (FileHeader.SizeOfOptionalHeader) {
	IMAGE_OPTIONAL_HEADER OptionalHeader;
  }
}

class ADDRESS extends DWORD(16)
{
	if (@value) {
		@linkTo = 8*@value;
	}
}

class RVA extends DWORD(16)
{
	if (@value) {
		var offset = @context.currentOffset;
		if (offset) {
			@linkTo = offset + 8*@value;
		} else {
			@linkTo = 8*@value;
		}
	}
}

class OFFSET extends DWORD(16)

class IMAGE_FILE_HEADER {
  IMAGE_FILE_MACHINE  Machine;
  WORD                NumberOfSections;
  DWORD               TimeDateStamp;      
  ADDRESS             PointerToSymbolTable;
  DWORD               NumberOfSymbols;
  WORD                SizeOfOptionalHeader;
  WORD                Characteristics;
}

class IMAGE_FILE_MACHINE extends WORD
{
	if (@value == 0x014c) {
		@attr[] = '"x86"';
	} else if (@value == 0x0200) {
		@attr[] = '"Intel Itanium"';
	} else if (@value == 0x8664) {
		@attr[] = '"x64"';
	}
}

class IMAGE_OPTIONAL_HEADER 
{
	WORD   Magic;
	var HDR64 = @global.HDR64 = (Magic == 0x20b);
	BYTE   MajorLinkerVersion;
	BYTE   MinorLinkerVersion;
	OFFSET  SizeOfCode;
	OFFSET  SizeOfInitializedData;
	OFFSET  SizeOfUninitializedData;
	OFFSET  AddressOfEntryPoint;
	OFFSET  BaseOfCode;
	if (HDR64) {
		ULONGLONG  ImageBase;
	} else {
		DWORD  BaseOfData;
		DWORD  ImageBase;
	}
	DWORD  SectionAlignment;
	DWORD  FileAlignment;
	WORD   MajorOperatingSystemVersion;
	WORD   MinorOperatingSystemVersion;
	WORD   MajorImageVersion;
	WORD   MinorImageVersion;
	WORD   MajorSubsystemVersion;
	WORD   MinorSubsystemVersion;
	DWORD  Win32VersionValue;
	DWORD  SizeOfImage;
	DWORD  SizeOfHeaders;
	DWORD  CheckSum;
	WORD   Subsystem;
	WORD   DllCharacteristics;
	
	var SIZE_TYPE = (HDR64 ? ULONGLONG(16) : DWORD(16));
	(SIZE_TYPE)  SizeOfStackReserve;
	(SIZE_TYPE)  SizeOfStackCommit;
	(SIZE_TYPE)  SizeOfHeapReserve;
	(SIZE_TYPE)  SizeOfHeapCommit;
	
	DWORD  LoaderFlags;
	DWORD  NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[NumberOfRvaAndSizes];
}

class IMAGE_DATA_DIRECTORY
{
	DWORD(16) VirtualAddress;
	DWORD(16) Size;
}

class IMAGE_SECTION_HEADER
{
    String(8) Name;
	@value = Name;
    DWORD(16) VirtualSize;
    DWORD(16) VirtualAddress;
    DWORD(16) SizeOfRawData;
    RVA PointerToRawData;
	@linkTo = PointerToRawData.@linkTo;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
}

class IMAGE_SECTION(name, _size, _virtualOffset) extends Data(_size << 3)
{

	var minVirtualOffset = @args._virtualOffset;
	var maxVirtualOffset = @args._virtualOffset + @args._size;
	var currentOffset = @context.currentOffset = @beginningPos - 8*minVirtualOffset;

	var count = @root._nt_header.OptionalHeader.NumberOfRvaAndSizes;

	DataDirectory := @root._nt_header.OptionalHeader.DataDirectory;
	
	for (var i = 0; i < count; ++i) {
		var directoryVirtualOffset = @root._nt_header.OptionalHeader.DataDirectory[i].VirtualAddress;

		if (minVirtualOffset <= directoryVirtualOffset && directoryVirtualOffset < maxVirtualOffset) {
			@pos = 8*(directoryVirtualOffset - minVirtualOffset);

			IMAGE_DIRECTORY_ENTRY(i, DataDirectory[i].Size << 3) _;
			@pos = 0;
		}
	}
}

class IMAGE_SECTIONS
{
	@args.@elementType = IMAGE_SECTION();
	var n = @args.@elementCount = @parent._nt_header.FileHeader.NumberOfSections;
	headers := @parent._section_headers;
	for (var i = 0; i < n; ++i) {
		header := headers[i];
		
		var sectionName          = header.Name;
		var sectionOffset        = header.PointerToRawData;
		if (sectionOffset) {
			var sectionSize          = header.SizeOfRawData;
			var sectionVirtualOffset = header.VirtualAddress;
			@pos = (sectionOffset << 3) - @beginningPos;
		} else {
			var sectionSize          = 0;
			var sectionVirtualOffset = 0;
		}
		IMAGE_SECTION(sectionName, sectionSize, sectionVirtualOffset) *;
	}
}

class IMAGE_DIRECTORY_ENTRY(index, _size) extends Data(-1)

//*********************************************************
// Export table
//*********************************************************
class IMAGE_DIRECTORY_ENTRY_EXPORT as IMAGE_DIRECTORY_ENTRY(0)
{
	IMAGE_EXPORT_DIRECTORY _directory;
	
	@pos = _directory.AddressOfFunctions.@linkTo - @beginningPos;
	DWORD FunctionsAddresses[_directory.NumberOfFunctions];
	
	var numberOfNames = _directory.NumberOfNames;
	
	@pos = _directory.AddressOfNames.@linkTo - @beginningPos;
	RVA NamesAddresses[numberOfNames];
	
	@pos = _directory.AddressOfNameOrdinals.@linkTo - @beginningPos;
	WORD NamesOrdinals[numberOfNames];
	
	@pos = _directory.Name.@linkTo - @beginningPos;
	String Name;
	
	if (numberOfNames > 0) {
		var minLink = NamesAddresses[0].@linkTo;
		for (var i = 1; i < numberOfNames; ++i) {
			var link = NamesAddresses[i].@linkTo;
			if (link < minLink) {
				link = minLink;
			}
		}
		
		@pos = minLink - @beginningPos;
		
		IMAGE_EXPORT_NAMES(numberOfNames) _names;
	}
}

class IMAGE_EXPORT_DIRECTORY
{
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    RVA     Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    RVA     AddressOfFunctions;
    RVA     AddressOfNames;
    RVA     AddressOfNameOrdinals;
}

class IMAGE_EXPORT_NAMES(_count) extends Data(-1)
{
	@args.@elementType = String();
	var count = @args.@elementCount = @args._count;
	for (var i = 0; i < count; ++i) {
		@pos = @parent.NamesAddresses[i].@linkTo - @beginningPos;
		String #;
		@pos = 0;
	}
}

//*********************************************************
// Import table
//*********************************************************
class IMAGE_DIRECTORY_ENTRY_IMPORT as IMAGE_DIRECTORY_ENTRY(1)
{
	IMAGE_IMPORT_DESCRIPTORS _descriptors;
	var originalPos = _descriptors.@size;
	IMAGE_IMPORT_NAMES _names;
	@pos = originalPos;
	IMAGE_IMPORT_DATAS _data;
}


class IMAGE_IMPORT_NAME extends String

class IMAGE_IMPORT_NAMES extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_NAME();
	var n = @args.@elementCount = @parent._descriptors.@numberOfChildren - 1;
	for  (var i = 0; i < n; ++i) {
		@pos = @parent._descriptors[i].Name.@linkTo - @beginningPos;
		IMAGE_IMPORT_NAME #;
	}
}

class IMAGE_IMPORT_DATAS extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_DATA();
	var n = @args.@elementCount = @parent._descriptors.@numberOfChildren - 1;
	for (var i = 0; i < n; ++i) {
		IMAGE_IMPORT_DATA(@parent._descriptors[i].OriginalFirstThunk.@linkTo) #;
		@pos = 0;
	}
}

class IMAGE_IMPORT_DATA(_originalFirstThunk) extends Data(-1)
{
	@pos = @args._originalFirstThunk - @beginningPos;
	IMAGE_THUNK_DATAS _data;
	var n = _data.@numberOfChildren - 1;
	var importCount = 0;
	for (var i = 0; i < n; ++i) {
		if (_data[i].@linkTo) {
			++importCount;
		}
	}
	if (importCount > 0) {
		IMAGE_IMPORT_BY_NAMES(importCount) _;
	}
}

class IMAGE_THUNK_DATA32 extends DWORD(16)
{
	if (@value & 0x80000000) {
		@attr.Ordinal = @value & 0x7fffffff;
	} else if (@value) {
		var offset = @context.currentOffset;
		if (offset) {
			@linkTo = offset + 8*@value;
		} else {
			@linkTo = 8*@value;
		}
		@attr.AddressOfData = @value;
	}
}

class IMAGE_THUNK_DATA64 extends ULONGLONG(16)
{
	if (@value & 0x8000000000000000) {
		@attr.Ordinal = @value & 0x7fffffffffffffff;
	} else if (@value) {
		var offset = @context.currentOffset;
		if (offset) {
			@linkTo = offset + 8*@value;
		} else {
			@linkTo = 8*@value;
		}
		@attr.AddressOfData = @value;
	}
}

class IMAGE_THUNK_DATAS
{
	if (@global.HDR64) {
		var elementType = IMAGE_THUNK_DATA64();
	} else {
		var elementType = IMAGE_THUNK_DATA32();
	}
	@args.@elementType = elementType;
	
	var n = 0;
	do {
		(elementType) #;
		++n;
	} while (self[] != 0)
	@args.@elementCount = n;
}

class IMAGE_IMPORT_DESCRIPTORS
{
	@args.@elementType = IMAGE_IMPORT_DESCRIPTOR();
	var n = 0;
	do {
		IMAGE_IMPORT_DESCRIPTOR #;
		++n;
	} while (self[].OriginalFirstThunk != 0 || self[].FirstThunk != 0)
	@args.@elementCount = n;
}

class IMAGE_IMPORT_DESCRIPTOR
{
    RVA   OriginalFirstThunk; // It points to the first thunk IMAGE_THUNK_DATA
	DWORD TimeDateStamp;      // 0 if not bound
	DWORD ForwarderChain;     // -1 if no forwarders
	RVA   Name;               // RVA of DLL Name.
	RVA   FirstThunk;         // RVA to IAT (if bound this IAT has actual addresses)
}

class IMAGE_IMPORT_BY_NAME
{
	WORD Hint;
	String Name;
    @attr.Hint = Hint;
    @attr.Name = Name;
}

class IMAGE_IMPORT_BY_NAMES(_count) extends Data(-1)
{
	@args.@elementType = IMAGE_IMPORT_BY_NAME();
	@args.@elementCount = @args._count;
	var n = @parent._data.@numberOfChildren - 1;
	for (var i = 0; i < n; ++i) {
		var linkTo = @parent._data[i].@linkTo;
		if (linkTo) {
			@pos = linkTo - @beginningPos;
			IMAGE_IMPORT_BY_NAME #;
		}
	}
}

//*********************************************************
// Resource
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_RESOURCE as IMAGE_DIRECTORY_ENTRY(2)
{
	@context.resourceRVAOffset = @beginningPos;
	currentResource := {
		"type" : "directory",
		"address" : @beginningPos-0,
		"level" : 0
	};
	for (; currentResource != undefined; currentResource := currentResource.next) {
		@context.currentResource := currentResource;
		
		if (currentResource.nameRVA) {
			@pos = currentResource.nameRVA - @beginningPos;
			IMAGE_RESOURCE_NAME resourceName;
			currentResource.name = self[];
		}
		@pos = currentResource.address - @beginningPos;
		if (currentResource.type == "directory") {
			IMAGE_RESOURCE_DIRECTORY directory;
		} else {
			IMAGE_RESOURCE_DATA_ENTRY leaf;
			@pos = self[].OffsetToData.@linkTo - @beginningPos;
			Data(self[].Size << 3) leafData;
			
		}
	}
}

class IMAGE_RESOURCE_NAME
{
	WORD count;
	WString(count) entryName;
	@value = entryName;
}

class IMAGE_RESOURCE_DIRECTORY
{
	resource := @context.currentResource;
	level := @attr.level = resource.level;
	if (resource.name != undefined) {
		@attr.name = resource.name;
	} else if (resource.integerId != undefined) {
		var id = @attr.id = resource.integerId;
		if (level == 1) {
			if (@global.resourceIds == undefined) {
				@global.resourceIds := [
					undefined,
					"cursor", //1
					"bitmap", //2
					"icon", //3
					"menu", //4
					"dialog", //5
					"string table", //6
					"font directory", //7
					"font", //8
					"accelerators", //9
					"unformatted resource data", //10
					"message table", //11
					"group cursor", //12
					undefined, //13
					"group icon", //14
					undefined,
					"version information", //16
					"dlginclude", //17
					undefined,
					"plug and play resource", //19
					"VXD", //20
					"animated cursor", //21
					"animated icon", //22
					"HTML", //23
					"side-by-side assembly manifest" //24
				];
			}
			var type = @global.resourceIds[id];
			if (type != undefined) {
				@attr.type = type;
			}
		}
	}
	
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD  MajorVersion;
	WORD  MinorVersion;
	WORD  NumberOfNamedEntries;
	WORD  NumberOfIdEntries;
	
	IMAGE_RESOURCE_DIRECTORY_ENTRY(0) NamedEntries[NumberOfNamedEntries];
	IMAGE_RESOURCE_DIRECTORY_ENTRY(1) IdEntries[NumberOfIdEntries];
	
	nextResource := resource.next;
	
	for (var i = 0; i < NumberOfNamedEntries; ++i) {
		entry := NamedEntries[i];
		var linkTo = entry.@linkTo;
		if (linkTo) {
			resource := resource.next := {
				"type" : entry.@attr.type,
				"nameRVA" : entry.NameRVA.@linkTo,
				"address" : linkTo,
				"level" : level + 1,
				"from" : @beginningPos
			};
		}
	}
	
	for (var j = 0; j < NumberOfIdEntries; ++j) {
		entry := IdEntries[j];
		var linkTo = entry.@linkTo;
		if (linkTo) {
			resource := resource.next := {
				"type" : entry.@attr.type,
				"integerId" : entry.IntegerID,
				"address" : linkTo,
				"level" : level + 1,
				"from" : @beginningPos
			};
		}
	}

	resource.next := nextResource;
}

class IMAGE_RESOURCE_DATA_ENTRY {
    resource := @context.currentResource;
	level := @attr.level = resource.level;
	RVA     OffsetToData;
    ULONG   Size;
    ULONG   CodePage;
    ULONG   Reserved;
}

class IMAGE_RESOURCE_DATA
{
	resource := @context.currentResource;
	level := @attr.level = resource.level;
	@size = resource.integerId << 3;
}

class IMAGE_RESOURCE_DIRECTORY_ENTRY(_withId)
{
	if (@args._withId) {
		DWORD IntegerID;
	} else {
		ResourceRVA NameRVA;
	}
	
	ResourceRVA _;
	@linkTo = self[].@linkTo;
	@attr.type = self[].@attr.type;
}

class ResourceRVA extends DWORD(16)
{
	if (@value & 0x80000000) {
		@value &= 0x7fffffff;
		@attr.type = "directory";
	} else if (@value) {
		@attr.type = "leaf";
	}

	@linkTo = @context.resourceRVAOffset + 8*@value;
}

//*********************************************************
// Exception
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_EXCEPTION as IMAGE_DIRECTORY_ENTRY(3)

//*********************************************************
// Security
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_SECURITY as IMAGE_DIRECTORY_ENTRY(4)

//*********************************************************
// Relocation table
//*********************************************************
class IMAGE_DIRECTORY_ENTRY_BASERELOC as IMAGE_DIRECTORY_ENTRY(5)
{
	do {
		IMAGE_BASE_RELOCATION #;
    } while (self[].VirtualAddress)
}

class IMAGE_BASE_RELOCATION
{
	DWORD VirtualAddress;
	DWORD SizeOfBlock;
	if (SizeOfBlock) {
		IMAGE_BASE_RELOCATION_ITEM _items [(8*SizeOfBlock-@pos)/%sizeof(WORD())];
	}
}

class IMAGE_BASE_RELOCATION_ITEM extends WORD
{
	@attr.Type = @value >> 12;
	@value &= 0x0fff;
}

//*********************************************************
// Debug
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_DEBUG as IMAGE_DIRECTORY_ENTRY(6)

//*********************************************************
// Copyright
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_COPYRIGHT as IMAGE_DIRECTORY_ENTRY(7)

//*********************************************************
// Global ptr
//*********************************************************

class IMAGE_DIRECTORY_ENTRY_EXCEPTION as IMAGE_DIRECTORY_ENTRY(8)

//********************************************************
// Thread local storage
//********************************************************

class IMAGE_DIRECTORY_ENTRY_TLS as IMAGE_DIRECTORY_ENTRY(9)

//********************************************************
// Load configuration
//********************************************************

class IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG as IMAGE_DIRECTORY_ENTRY(10)

//********************************************************
// Bound import
//********************************************************

class IMAGE_DIRECTORY_BOUND_IMPORT as IMAGE_DIRECTORY_ENTRY(11)

//********************************************************
// Import address table
//********************************************************

class IMAGE_DIRECTORY_ENTRY_IAT as IMAGE_DIRECTORY_ENTRY(12)

//********************************************************
// Delay import descriptor
//********************************************************

class IMAGE_DIRECTORY_ENTRY_DELAY as IMAGE_DIRECTORY_ENTRY(13)

//********************************************************
// COM+ Runtime Header
//********************************************************

class IMAGE_DIRECTORY_ENTRY_COM as IMAGE_DIRECTORY_ENTRY(14)
